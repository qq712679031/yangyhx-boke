import{_ as t,M as d,p as i,q as l,R as e,t as s,N as n,a1 as r}from"./framework-5866ffd3.js";const c={},o={href:"https://github.com/alibaba/RedisShake/wiki/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%9F",target:"_blank",rel:"noopener noreferrer"},p=r(`<ol><li>下载解压</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">wget</span> <span class="token parameter variable">-c</span> https://github.com/alibaba/RedisShake/releases/download/release-v1.6.24-20191220/redis-shake-1.6.24.tar.gz
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span>  redis-shake-1.6.24.tar.gz
<span class="token builtin class-name">cd</span>  redis-shake-1.6.24.tar.gz
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>配置文件</li></ol><p>主要修改以下参数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 支持按前缀过滤key，只让指定前缀的key通过，分号分隔。比如指定abc，将会通过abc, abc1, abcxxx</span>
filter.key.whitelist <span class="token operator">=</span>
<span class="token comment"># 支持按前缀过滤key，不让指定前缀的key通过，分号分隔。比如指定abc，将会阻塞abc, abc1, abcxxx</span>
filter.key.blacklist <span class="token operator">=</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例: 1.单个节点到单个节点配置举例。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>source.type: standalone
source.address: <span class="token number">10.1</span>.1.1:20441
source.password_raw: <span class="token number">12345</span>
target.type: standalone
target.address: <span class="token number">10.1</span>.1.1:20551
target.password_raw: <span class="token number">12345</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.2 集群版cluster到集群版cluster配置举例</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>source.type: cluster
source.address: <span class="token number">10.1</span>.1.1:20441<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:20443<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:20445
source.password_raw: <span class="token number">12345</span>
target.type: cluster
target.address: <span class="token number">10.1</span>.1.1:20551<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:20553<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:20555
target.password_raw: <span class="token number">12345</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于source.address或者target.address，需要配置源端的所有集群中db节点列表以及目的端集群所有db节点列表，用户也可以启用自动发现机制，地址以&#39;@&#39;开头，redis-shake将会根据cluster nodes命令自动去探测有几个节点。对于source.address，用户可以在&#39;@&#39;前面配置master（默认）或者slave表示分表从master或者slave进行拉取；对于target.address，只能是master或者不配置：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>source.type: cluster
source.address: master@10.1.1.1:20441 <span class="token comment"># 将会自动探测到10.1.1.1:20441集群下的所有节点，并从所有master进行拉取。同理如果是slave@10.1.1.1:20441将会扫描集群下的所有slave节点。</span>
source.password_raw: <span class="token number">12345</span>
target.type: cluster
target.address: @10.1.1.1:20551 <span class="token comment"># 将会自动探测到10.1.1.1:20551集群下的所有节点，并写入所有master。</span>
target.password_raw: <span class="token number">12345</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上的说明是开源cluster，当然，源端也可以是别的集群架构模式，比如带proxy的集群（比如codis，或者别的云集群架构，但这种情况下有些不支持自动发现，需要手动配置所有master或者slave的地址），那么需要选择db节点进行拉取，source.type同样选择cluster，source.address后面跟所有db的地址（只要主或者从的其中一个即可）。 2.3 集群版cluster到proxy配置举例</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>source.type: cluster
source.address: <span class="token number">10.1</span>.1.1:20441<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:20443<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:20445<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:20447
source.password_raw: <span class="token number">12345</span>
target.type: proxy
target.address: <span class="token number">10.1</span>.1.1:30331<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:30441<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:30551
target.password_raw: <span class="token number">12345</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,13),u={href:"https://github.com/alibaba/RedisShake/wiki/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE%EF%BC%9F#32-%E9%9B%86%E7%BE%A4%E7%89%88cluster%E5%88%B0%E9%9B%86%E7%BE%A4%E7%89%88cluster%E9%85%8D%E7%BD%AE%E4%B8%BE%E4%BE%8B",target:"_blank",rel:"noopener noreferrer"},b=r(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>source.type: standalone
source.address: <span class="token number">10.1</span>.1.1:20441
source.password_raw: <span class="token number">12345</span>
target.type: cluster
target.address: <span class="token number">10.1</span>.1.1:30331<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:30441<span class="token punctuation">;</span><span class="token number">10.1</span>.1.1:30551
target.password_raw: <span class="token number">12345</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>启动</li></ol><p>启动二进制：./redis-shake.linux -conf=redis-shake.conf -type=xxx # xxx为sync, restore, dump, decode, rump其中之一，全量+增量同步请选择sync。 mac下请使用redis-shake.darwin，windows请用redis-shake.windows. <strong>decode</strong>: 把Redis RDB文件解析成人类可读的文件格式. <strong>restore</strong>: 把Rdis RDB文件作为数据源，恢复到目标Redis实例中. <strong>dump</strong>: 对源Redis实例中的数据dump到RDB文件中. <strong>sync</strong>: 基于Redis sync/psync命令从源redis实例同步到目标Redis实例，该模式包含全量同步和增量同步两个阶段。（通过默认Redis Slave来实现） <strong>rump</strong>: 基于Redis scan命令的方式从源Redis同步到目标Redis实例。只支持全量同步，这种方式通常适用于源redis不支持sync/psync命令的场景</p>`,3);function m(v,k){const a=d("ExternalLinkIcon");return i(),l("div",null,[e("p",null,[s("参考完档 "),e("a",o,[s("RedisShake"),n(a)])]),p,e("p",null,[s("source.address同样支持自动发现机制，参考"),e("a",u,[s("3.2"),n(a)]),s("。此外，target.address为proxy的地址，proxy支持roundrobin写入，也就是说，对于这个配置来说，10.1.1.1:20441和10.1.1.1:20447将会写入10.1.1.1:30331；10.1.1.1:20443写入10.1.1.1:30441；10.1.1.1:20445写入10.1.1.1:30551。 如3.2中所述，源端也可以是别的集群架构模式。 2.4 主从版/单节点到cluster配置举例")]),b])}const h=t(c,[["render",m],["__file","redisShake.html.vue"]]);export{h as default};
