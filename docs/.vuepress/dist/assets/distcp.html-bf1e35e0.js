import{_ as d,M as i,p as r,q as l,R as e,t as n,N as s,a1 as t}from"./framework-5866ffd3.js";const o={},c=t(`<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>DistCp（分布式拷贝）是用于大规模集群内部和集群之间拷贝的工具。 它使用Map/Reduce实现文件分发，错误处理和恢复，以及报告生成。 它把文件和目录的列表作为map任务的输入，每个任务会完成源列表中部分文件的拷贝。 由于使用了Map/Reduce方法，这个工具在语义和执行上都会有特殊的地方。 这篇文档会为常用DistCp操作提供指南并阐述它的工作模型。</p><h2 id="使用方法" tabindex="-1"><a class="header-anchor" href="#使用方法" aria-hidden="true">#</a> 使用方法</h2><h3 id="基本使用方法" tabindex="-1"><a class="header-anchor" href="#基本使用方法" aria-hidden="true">#</a> 基本使用方法</h3><p>DistCp最常用在集群之间的拷贝：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash$ hadoop distcp hdfs://nn1:8020/foo/bar <span class="token punctuation">\\</span>
      hdfs://nn2:8020/bar/foo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这条命令会把nn1集群的/foo/bar目录下的所有文件或目录名展开并存储到一个临时文件中，这些文件内容的拷贝工作被分配给多个map任务， 然后每个TaskTracker分别执行从nn1到nn2的拷贝操作。注意DistCp使用绝对路径进行操作。</p><p>命令行中可以指定多个源目录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash$ hadoop distcp hdfs://nn1:8020/foo/a <span class="token punctuation">\\</span>
          hdfs://nn1:8020/foo/b <span class="token punctuation">\\</span>
          hdfs://nn2:8020/bar/foo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者使用-f选项，从文件里获得多个源：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bash$ hadoop distcp <span class="token parameter variable">-f</span> hdfs://nn1:8020/srclist <span class="token punctuation">\\</span>
             hdfs://nn2:8020/bar/foo
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中srclist 的内容是</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  hdfs://nn1:8020/foo/a
  hdfs://nn1:8020/foo/b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,13),p={href:"https://hadoop.apache.org/docs/r1.0.4/cn/distcp.html#options",target:"_blank",rel:"noopener noreferrer"},h={href:"https://hadoop.apache.org/docs/r1.0.4/cn/distcp.html#etc",target:"_blank",rel:"noopener noreferrer"},u={href:"https://hadoop.apache.org/docs/r1.0.4/cn/distcp.html#cpver",target:"_blank",rel:"noopener noreferrer"},b=e("p",null,"拷贝完成后，建议生成源端和目的端文件的列表，并交叉检查，来确认拷贝真正成功。 因为DistCp使用Map/Reduce和文件系统API进行操作，所以这三者或它们之间有任何问题 都会影响拷贝操作。一些Distcp命令的成功执行可以通过再次执行带-update参数的该命令来完成， 但用户在如此操作之前应该对该命令的语法很熟悉。",-1),m=e("p",null,"值得注意的是，当另一个客户端同时在向源文件写入时，拷贝很有可能会失败。 尝试覆盖HDFS上正在被写入的文件的操作也会失败。 如果一个源文件在拷贝之前被移动或删除了，拷贝失败同时输出异常 FileNotFoundException。",-1),v=e("h3",{id:"选项",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#选项","aria-hidden":"true"},"#"),n(" 选项")],-1),f=e("h4",{id:"选项索引",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#选项索引","aria-hidden":"true"},"#"),n(" 选项索引")],-1),g=e("thead",null,[e("tr",null,[e("th",{style:{"text-align":"center"}},"标识"),e("th",{style:{"text-align":"center"}},"描述"),e("th",{style:{"text-align":"center"}},"备注")])],-1),_=e("tr",null,[e("td",{style:{"text-align":"center"}},"-p[rbugp]"),e("td",{style:{"text-align":"center"}},"Preserve r: replication number b: block size u: user g: group p: permission"),e("td",{style:{"text-align":"center"}},[n("修改次数不会被保留。并且当指定 -update 时，更新的状态"),e("strong",null,"不"),n("会 被同步，除非文件大小不同（比如文件被重新创建）。")])],-1),x=e("td",{style:{"text-align":"center"}},"-i",-1),k=e("td",{style:{"text-align":"center"}},"忽略失败",-1),y={style:{"text-align":"center"}},D={href:"https://hadoop.apache.org/docs/r1.0.4/cn/distcp.html#etc",target:"_blank",rel:"noopener noreferrer"},C=e("tr",null,[e("td",{style:{"text-align":"center"}},[n("-log "),e("code",null,"<logdir>")]),e("td",{style:{"text-align":"center"}},[n("记录日志到 "),e("code",null,"<logdir>")]),e("td",{style:{"text-align":"center"}},"DistCp为每个文件的每次尝试拷贝操作都记录日志，并把日志作为map的输出。 如果一个map失败了，当重新执行时这个日志不会被保留。")],-1),M=e("tr",null,[e("td",{style:{"text-align":"center"}},"-m <num_maps>"),e("td",{style:{"text-align":"center"}},"同时拷贝的最大数目"),e("td",{style:{"text-align":"center"}},"指定了拷贝数据时map的数目。请注意并不是map数越多吞吐量越大。")],-1),T=e("td",{style:{"text-align":"center"}},"-overwrite",-1),F=e("td",{style:{"text-align":"center"}},"覆盖目标",-1),N={style:{"text-align":"center"}},R={href:"https://hadoop.apache.org/docs/r1.0.4/cn/distcp.html#uo",target:"_blank",rel:"noopener noreferrer"},w=e("td",{style:{"text-align":"center"}},"-update",-1),H=e("td",{style:{"text-align":"center"}},"如果源和目标的大小不一样则进行覆盖",-1),S={style:{"text-align":"center"}},B={href:"https://hadoop.apache.org/docs/r1.0.4/cn/distcp.html#uo",target:"_blank",rel:"noopener noreferrer"},E=e("tr",null,[e("td",{style:{"text-align":"center"}},"-f <urilist_uri>"),e("td",{style:{"text-align":"center"}},"使用<urilist_uri> 作为源文件列表"),e("td",{style:{"text-align":"center"}},"这等价于把所有文件名列在命令行中。 urilist_uri 列表应该是完整合法的URI。")],-1),I=t(`<h4 id="更新和覆盖" tabindex="-1"><a class="header-anchor" href="#更新和覆盖" aria-hidden="true">#</a> 更新和覆盖</h4><p>这里给出一些 -update和 -overwrite的例子。 考虑一个从/foo/a 和 /foo/b 到 /bar/foo的拷贝，源路径包括：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  hdfs://nn1:8020/foo/a
  hdfs://nn1:8020/foo/a/aa
  hdfs://nn1:8020/foo/a/ab
  hdfs://nn1:8020/foo/b
  hdfs://nn1:8020/foo/b/ba
  hdfs://nn1:8020/foo/b/ab
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果没设置-update或 -overwrite选项， 那么两个源都会映射到目标端的 /bar/foo/ab。 如果设置了这两个选项，每个源目录的内容都会和目标目录的 <strong>内容</strong> 做比较。DistCp碰到这类冲突的情况会终止操作并退出。</p><p>默认情况下，/bar/foo/a 和 /bar/foo/b 目录都会被创建，所以并不会有冲突。</p><p>现在考虑一个使用-update合法的操作:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>distcp <span class="token parameter variable">-update</span> hdfs://nn1:8020/foo/a <span class="token punctuation">\\</span>
        hdfs://nn1:8020/foo/b <span class="token punctuation">\\</span>
        hdfs://nn2:8020/bar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中源路径/大小:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  hdfs://nn1:8020/foo/a
  hdfs://nn1:8020/foo/a/aa <span class="token number">32</span>
  hdfs://nn1:8020/foo/a/ab <span class="token number">32</span>
  hdfs://nn1:8020/foo/b
  hdfs://nn1:8020/foo/b/ba <span class="token number">64</span>
  hdfs://nn1:8020/foo/b/bb <span class="token number">32</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和目的路径/大小:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  hdfs://nn2:8020/bar
  hdfs://nn2:8020/bar/aa <span class="token number">32</span>
  hdfs://nn2:8020/bar/ba <span class="token number">32</span>
  hdfs://nn2:8020/bar/bb <span class="token number">64</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会产生:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  hdfs://nn2:8020/bar
  hdfs://nn2:8020/bar/aa <span class="token number">32</span>
  hdfs://nn2:8020/bar/ab <span class="token number">32</span>
  hdfs://nn2:8020/bar/ba <span class="token number">64</span>
  hdfs://nn2:8020/bar/bb <span class="token number">32</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有nn2的aa文件没有被覆盖。如果指定了 -overwrite选项，所有文件都会被覆盖。</p><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录" aria-hidden="true">#</a> 附录</h2><h3 id="map数目" tabindex="-1"><a class="header-anchor" href="#map数目" aria-hidden="true">#</a> Map数目</h3><p>DistCp会尝试着均分需要拷贝的内容，这样每个map拷贝差不多相等大小的内容。 但因为文件是最小的拷贝粒度，所以配置增加同时拷贝（如map）的数目不一定会增加实际同时拷贝的数目以及总吞吐量。</p><p>如果没使用-m选项，DistCp会尝试在调度工作时指定map的数目 为 min (total_bytes / bytes.per.map, 20 * num_task_trackers)， 其中bytes.per.map默认是256MB。</p><p>建议对于长时间运行或定期运行的作业，根据源和目标集群大小、拷贝数量大小以及带宽调整map的数目。</p><h3 id="不同hdfs版本间的拷贝" tabindex="-1"><a class="header-anchor" href="#不同hdfs版本间的拷贝" aria-hidden="true">#</a> 不同HDFS版本间的拷贝</h3><p>对于不同Hadoop版本间的拷贝，用户应该使用HftpFileSystem。 这是一个只读文件系统，所以DistCp必须运行在目标端集群上（更确切的说是在能够写入目标集群的TaskTracker上）。 源的格式是 hftp://&lt;dfs.http.address&gt;/<code>&lt;path&gt;</code> （默认情况dfs.http.address是 <code>&lt;namenode&gt;</code>:50070）。</p><h3 id="map-reduce和副效应" tabindex="-1"><a class="header-anchor" href="#map-reduce和副效应" aria-hidden="true">#</a> Map/Reduce和副效应</h3><p>像前面提到的，map拷贝输入文件失败时，会带来一些副效应。</p><ul><li>除非使用了-i，任务产生的日志会被新的尝试替换掉。</li><li>除非使用了-overwrite，文件被之前的map成功拷贝后当又一次执行拷贝时会被标记为 &quot;被忽略&quot;。</li><li>如果map失败了mapred.map.max.attempts次，剩下的map任务会被终止（除非使用了-i)。</li><li>如果mapred.speculative.execution被设置为 final和true，则拷贝的结果是未定义的。</li></ul>`,24);function V(q,$){const a=i("ExternalLinkIcon");return r(),l("div",null,[c,e("p",null,[n("当从多个源拷贝时，如果两个源冲突，DistCp会停止拷贝并提示出错信息， 如果在目的位置发生冲突，会根据"),e("a",p,[n("选项设置"),s(a)]),n("解决。 默认情况会跳过已经存在的目标文件（比如不用源文件做替换操作）。每次操作结束时 都会报告跳过的文件数目，但是如果某些拷贝操作失败了，但在之后的尝试成功了， 那么报告的信息可能不够精确（请参考"),e("a",h,[n("附录"),s(a)]),n("）。")]),e("p",null,[n("每个TaskTracker必须都能够与源端和目的端文件系统进行访问和交互。 对于HDFS来说，源和目的端要运行相同版本的协议或者使用向下兼容的协议。 （请参考"),e("a",u,[n("不同版本间的拷贝"),s(a)]),n(" ）。")]),b,m,v,f,e("table",null,[g,e("tbody",null,[_,e("tr",null,[x,k,e("td",y,[n("就像在 "),e("a",D,[n("附录"),s(a)]),n("中提到的，这个选项会比默认情况提供关于拷贝的更精确的统计， 同时它还将保留失败拷贝操作的日志，这些日志信息可以用于调试。最后，如果一个map失败了，但并没完成所有分块任务的尝试，这不会导致整个作业的失败。")])]),C,M,e("tr",null,[T,F,e("td",N,[n("如果一个map失败并且没有使用-i选项，不仅仅那些拷贝失败的文件，这个分块任务中的所有文件都会被重新拷贝。 就像"),e("a",R,[n("下面"),s(a)]),n("提到的，它会改变生成目标路径的语义，所以 用户要小心使用这个选项。")])]),e("tr",null,[w,H,e("td",S,[n('像之前提到的，这不是"同步"操作。 执行覆盖的唯一标准是源文件和目标文件大小是否相同；如果不同，则源文件替换目标文件。 像 '),e("a",B,[n("下面"),s(a)]),n("提到的，它也改变生成目标路径的语义， 用户使用要小心。")])]),E])]),I])}const P=d(o,[["render",V],["__file","distcp.html.vue"]]);export{P as default};
